# React Router Complete Guide

## 🔍 Understanding Key Concepts with Visual Examples

### Why Do We Need `<Outlet />`?

#### ❌ WITHOUT Outlet - Routes are Completely Separate
```
Route Structure WITHOUT Outlet:
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│     Route: /    │    │  Route: /about  │    │ Route: /contact │
│   <Navbar />    │    │   <About />     │    │  <Contact />    │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │    Home     │ │    │ │ About Page  │ │    │ │ Contact Page│ │
│ │   Content   │ │    │ │   Content   │ │    │ │   Content   │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘

Problem: Navbar disappears when you navigate!
Each route renders ONLY its own component.
```

#### ✅ WITH Outlet - Shared Layout + Dynamic Content
```
Route Structure WITH Outlet:
┌─────────────────────────────────────────────────────────────┐
│                    <Navbar /> (Always Present)             │
│  ┌─────┐  ┌─────┐  ┌─────┐                                 │
│  │Home │  │About│  │Cont.│  ← Navigation Links             │
│  └─────┘  └─────┘  └─────┘                                 │
├─────────────────────────────────────────────────────────────┤
│                    <Outlet />                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  Dynamic Content Changes Based on Route:               │ │
│  │  / → <Home />                                          │ │
│  │  /about → <About />                                    │ │
│  │  /contact → <Contact />                                │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

Result: Navbar stays, only content area changes!
```

### 🔄 Navigation Flow Visualization

#### Regular `<a>` tag vs `<Link>` Component
```
Regular <a> tag Navigation:
User clicks → Browser requests new page → Server sends HTML → Page reloads
┌─────┐    ┌──────────┐    ┌────────┐    ┌─────────┐
│Click│───▶│ Browser  │───▶│ Server │───▶│Full Page│
│  a  │    │ Request  │    │Response│    │ Reload  │
└─────┘    └──────────┘    └────────┘    └─────────┘
Result: ❌ Page flickers, state lost, slower

React Router <Link> Navigation:
User clicks → JavaScript updates URL → Component changes → No reload
┌─────┐    ┌──────────┐    ┌───────────┐
│Click│───▶│JavaScript│───▶│Component  │
│Link │    │URL Update│    │ Changes   │
└─────┘    └──────────┘    └───────────┘
Result: ✅ Instant, smooth, state preserved
```

### 📊 Data Passing Flow

#### Method 1: Using State
```
Component A (Sender)          Component B (Receiver)
┌─────────────────┐          ┌─────────────────┐
│  const data = { │          │ const location  │
│   name: "John"  │          │ = useLocation() │
│  }              │          │                 │
│                 │          │ const {state}   │
│ navigate('/B',  │ ────────▶│ = location      │
│ {state: data})  │          │                 │
│                 │          │ // state.name   │
└─────────────────┘          └─────────────────┘

Flow: Sender → Router → Receiver (via location.state)
```

#### Method 2: Using URL Parameters
```
URL: /product/123
        │
        ▼
Component receives via useParams():
┌─────────────────┐
│ const {id} =    │
│ useParams()     │
│                 │
│ // id = "123"   │
└─────────────────┘

Flow: URL → Router → Component (via params)
```

## Lesson 1: Basic Router Setup

### Step 1: Install and Import
```jsx
// main.jsx
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
```

### Step 2: Create Basic Routes
```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <Home />
  },
  {
    path: '/about',
    element: <About />
  }
]);
```

### Step 3: Provide Router
```jsx
createRoot(document.getElementById('root')).render(
  <StrictMode>
    <RouterProvider router={router}/>
  </StrictMode>
)
```

---

## ⚠️ Common Mistakes & Solutions

### Mistake 1: Using Both useParams and useLocation
```
❌ WRONG - Causes Conflicts:
const { id } = useParams();           // Gets ID from URL
const { state } = useLocation();     // Gets data from navigation state
// Both trying to provide the same data!

✅ CORRECT - Choose One Method:
Method A: URL Parameters
const { id } = useParams();
// Get data by making API call with ID

Method B: Navigation State  
const { state } = useLocation();
// Use data passed during navigation
```

### Mistake 2: Forgetting Error Boundaries
```
Without Error Boundary:
Component Error → Entire App Crashes → White Screen of Death

┌─────────────────┐    ERROR    ┌─────────────────┐
│   Component     │ ──────────▶ │   Entire App    │
│     Error       │             │    Crashes      │
└─────────────────┘             └─────────────────┘

With Error Boundary:
Component Error → Show Error Page → Rest of App Works

┌─────────────────┐    ERROR    ┌─────────────────┐
│   Component     │ ──────────▶ │  Error Page     │
│     Error       │             │   (Graceful)    │
└─────────────────┘             └─────────────────┘
```

### Mistake 3: Not Handling Loading States
```
❌ Poor User Experience:
API Call → Long Wait → Sudden Content Appearance

┌─────────┐     ???     ┌─────────┐
│  Click  │ ──────────▶│ Content │
│  Link   │   (Wait)    │Appears  │
└─────────┘             └─────────┘
User thinks: "Is it broken?"

✅ Good User Experience:
API Call → Show Loading → Show Content

┌─────────┐    ┌─────────┐    ┌─────────┐
│  Click  │───▶│Loading  │───▶│ Content │
│  Link   │    │Spinner  │    │Appears  │
└─────────┘    └─────────┘    └─────────┘
User knows: "It's working!"
```

---

## 📋 Quick Decision Tree

### When to Use Which Hook?
```
Need to Navigate Programmatically?
├── YES → useNavigate()
│   ├── After form submission
│   ├── After login success  
│   └── Conditional redirects
│
└── NO → Need Data?
    ├── From URL? → useParams()
    │   └── /product/123 → get "123"
    │
    ├── From Navigation? → useLocation()
    │   └── navigate('/page', {state: data})
    │
    └── Handle Errors? → useRouteError()
        └── In error boundary components
```

---

## 🎯 Best Practices Summary

### 1. Route Organization
```
✅ Good Structure:
/src
  /pages
    Home.jsx
    About.jsx
    Products.jsx
  /components  
    Navbar.jsx
    ProductCard.jsx
  /routes
    ProtectedRoute.jsx
  main.jsx
```

### 2. Loading Pattern
```jsx
// ✅ Always handle these 3 states
const [data, setData] = useState([]);
const [loading, setLoading] = useState(false);
const [error, setError] = useState('');

// Show appropriate UI for each state
if (loading) return <div>Loading...</div>;
if (error) return <div>Error: {error}</div>;
return <div>{/* Render data */}</div>;
```

### 3. Navigation Pattern
```jsx
// ✅ Use Link for navigation links
<Link to="/about">About</Link>

// ✅ Use navigate for programmatic navigation
const navigate = useNavigate();
const handleSuccess = () => navigate('/success');
```

---

## Lesson 2: Navigation with Link

### Problem with Regular Links
```jsx
// ❌ This causes page refresh
<a href="/about">About</a>
```

### Solution: Use Link
```jsx
// ✅ No page refresh
import { Link } from 'react-router-dom'

<Link to="/about">About</Link>
```

### Basic Navbar Component
```jsx
import { Link } from 'react-router-dom'

const Navbar = () => {
  return (
    <nav>
      <ul>
        <li><Link to="/">Home</Link></li>
        <li><Link to="/about">About</Link></li>
        <li><Link to="/contact">Contact</Link></li>
      </ul>
    </nav>
  );
};
```

---

## Lesson 3: Nested Routes with Outlet

### Step 1: Update Navbar Component
```jsx
import { Link, Outlet } from 'react-router-dom'

const Navbar = () => {
  return (
    <>
      <nav>
        <ul>
          <li><Link to="/">Home</Link></li>
          <li><Link to="/about">About</Link></li>
        </ul>
      </nav>
      <Outlet /> {/* Child routes render here */}
    </>
  );
};
```

### Step 2: Setup Nested Routes
```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <Navbar />,
    children: [
      {
        path: '/',
        element: <Home />
      },
      {
        path: '/about',
        element: <About />
      }
    ]
  },
  {
    path: '/*',
    element: <div>Page Not Found!</div>
  }
]);
```

---

## Lesson 4: Programmatic Navigation

### Using useNavigate Hook
```jsx
import { useNavigate } from 'react-router-dom';

const Contact = () => {
  const navigate = useNavigate();

  const handleNavigate = () => {
    navigate('/'); // Go to home page
  };

  return (
    <div>
      <h3>Contact Page</h3>
      <button onClick={handleNavigate}>Go to Home</button>
    </div>
  );
};
```

---

## Lesson 5: Passing Data Between Routes

### Method 1: Using State
```jsx
// Sending data
const navigate = useNavigate();
const userData = { name: "John", age: 25 };

navigate('/profile', { state: userData });
```

```jsx
// Receiving data
import { useLocation } from 'react-router-dom';

const Profile = () => {
  const location = useLocation();
  const { state } = location;
  
  return (
    <div>
      {state ? (
        <p>Welcome, {state.name}!</p>
      ) : (
        <p>No user data</p>
      )}
    </div>
  );
};
```

---

## Lesson 6: Simple Login System

### SignIn Component
```jsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';

const SignIn = () => {
  const navigate = useNavigate();
  const [user, setUser] = useState({
    userName: '',
    password: ''
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (user.userName === 'admin' && user.password === '123') {
      navigate('/profile', { state: user });
    } else {
      alert('Invalid credentials');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Username"
        value={user.userName}
        onChange={(e) => setUser({...user, userName: e.target.value})}
      />
      <input
        type="password"
        placeholder="Password"
        value={user.password}
        onChange={(e) => setUser({...user, password: e.target.value})}
      />
      <button type="submit">Login</button>
    </form>
  );
};
```

---

## Lesson 7: URL Parameters with useParams

### Setup Route with Parameter
```jsx
const router = createBrowserRouter([
  {
    path: '/product/:id',
    element: <ProductDetails />
  }
]);
```

### Link with Parameter
```jsx
<Link to={`/product/${productId}`}>View Product</Link>
```

### Get Parameter in Component
```jsx
import { useParams } from 'react-router-dom';

const ProductDetails = () => {
  const { id } = useParams();
  
  return <div>Product ID: {id}</div>;
};
```

---

## Lesson 8: Loading States & API Data

### Product List Component
```jsx
import { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';

const Products = () => {
  const [products, setProducts] = useState([]);
  const [isLoading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetch('https://dummyjson.com/products')
      .then(res => res.json())
      .then(data => {
        setProducts(data.products);
        setLoading(false);
      })
      .catch(err => {
        setError('Failed to load products');
        setLoading(false);
      });
  }, []);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <h3>{product.title}</h3>
          <p>${product.price}</p>
          <Link to={`/product/${product.id}`}>View Details</Link>
        </div>
      ))}
    </div>
  );
};
```

---

## Lesson 9: Error Handling

### Error Component
```jsx
import { useRouteError } from 'react-router-dom';

const ErrorPage = () => {
  const error = useRouteError();
  
  return (
    <div>
      <h2>Oops! Something went wrong</h2>
      <p>{error?.message || 'Unknown error occurred'}</p>
      <Link to="/">Go Home</Link>
    </div>
  );
};
```

### Add Error Boundary to Routes
```jsx
const router = createBrowserRouter([
  {
    path: '/',
    element: <Navbar />,
    errorElement: <ErrorPage />,
    children: [
      // your routes here
    ]
  }
]);
```

---

## Lesson 10: Route Protection

### 🛡️ Route Protection Flow
```
User tries to access /admin/dashboard:

Step 1: Check Authentication
┌─────────────┐    YES    ┌─────────────┐
│ isLoggedIn? │ ────────▶ │ Check Role  │
│             │           │ isAdmin?    │
└─────────────┘           └─────────────┘
      │ NO                       │ NO
      ▼                          ▼
┌─────────────┐           ┌─────────────┐
│   Redirect  │           │   Show      │
│ to <SignIn />│           │"Access      │
│             │           │ Denied"     │
└─────────────┘           └─────────────┘
                                │ YES
                                ▼
                         ┌─────────────┐
                         │   Render    │
                         │  <Outlet /> │
                         │ (Dashboard) │
                         └─────────────┘
```

### Protected Route Component
```jsx
import { Outlet } from 'react-router-dom';

const ProtectedRoute = () => {
  const isLoggedIn = true; // Replace with actual auth logic
  const isAdmin = true;    // Replace with actual role check
  
  if (!isLoggedIn) {
    return <SignIn />;
  }
  
  if (!isAdmin) {
    return <div>Access Denied: Admin only!</div>;
  }
  
  return <Outlet />;
};
```

### Setup Protected Routes
```jsx
const router = createBrowserRouter([
  {
    path: '/admin',
    element: <ProtectedRoute />,
    children: [
      {
        path: 'dashboard',
        element: <AdminDashboard />
      }
    ]
  }
]);
```

---

## 🔧 Error Handling Visualization

### Error Boundary Flow
```
When Error Occurs:
┌─────────────┐    ERROR    ┌─────────────────┐
│  Component  │ ──────────▶ │ Error Boundary  │
│   Crashes   │             │   Catches It    │
└─────────────┘             └─────────────────┘
                                    │
                                    ▼
                             ┌─────────────────┐
                             │   Show Error    │
                             │     Page        │
                             │ (User-friendly) │
                             └─────────────────┘

Without Error Boundary: Whole app crashes ❌
With Error Boundary: Only that route shows error page ✅
```

---

## 🏗️ Complete Route Structure Example

### Visual Route Tree
```
Application Route Structure:
┌─────────────────────────────────────┐
│              App Root               │
│         <RouterProvider />          │
└─────────────────┬───────────────────┘
                  │
    ┌─────────────┴─────────────┐
    │         Navbar            │ ← Layout Component
    │      <Outlet />           │   (Always Present)
    └─────────────┬─────────────┘
                  │
        ┌─────────┼─────────┐
        │         │         │
   ┌────▼───┐┌───▼───┐┌───▼────┐
   │  Home  ││ About ││Products│ ← Page Components
   │   /    ││ /about││/product││   (Switch based on URL)
   └────────┘└───────┘└───┬────┘
                          │
                    ┌─────▼─────┐
                    │  Product  │ ← Nested Route
                    │ Details   │   /product/:id
                    │  /:id     │
                    └───────────┘
```

---

## 🔄 State Management Across Routes

### Component Lifecycle During Navigation
```
Navigation: Home → About

Home Component:              About Component:
┌─────────────┐             ┌─────────────┐
│   MOUNTED   │             │             │
│             │             │   WAITING   │
│ ┌─────────┐ │   Navigate  │             │
│ │ State:  │ │ ──────────▶ │             │
│ │ Active  │ │             │             │
│ └─────────┘ │             │             │
└─────────────┘             └─────────────┘
       │                            │
       ▼                            ▼
┌─────────────┐             ┌─────────────┐
│ UNMOUNTING  │             │   MOUNTING  │
│             │             │             │
│ State Lost! │             │ Fresh Start │
│             │             │             │
└─────────────┘             └─────────────┘

Key Point: Each route component has its own lifecycle!
State doesn't automatically persist between routes.
```

---

## 🚦 Loading States Pattern

### API Call Flow with States
```
Component Mounts → Start API Call → Handle Response

Initial State:        Loading State:       Success State:
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│ data: []    │────▶ │ data: []    │────▶ │ data: [...]  │
│ loading:    │      │ loading:    │      │ loading:     │
│   false     │      │   true      │      │   false      │
│ error: ""   │      │ error: ""   │      │ error: ""    │
└─────────────┘      └─────────────┘      └─────────────┘
      │                       │                    │
      ▼                       ▼                    ▼
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   Show      │      │   Show      │      │   Show      │
│ "No Data"   │      │ "Loading..."│      │   Data      │
└─────────────┘      └─────────────┘      └─────────────┘
                             │
                             ▼ (If API fails)
                     ┌─────────────┐      ┌─────────────┐
                     │ data: []    │      │   Show      │
                     │ loading:    │      │   Error     │
                     │   false     │      │  Message    │
                     │ error: "..."│      │             │
                     └─────────────┘      └─────────────┘
```

---

## Quick Reference

### Essential Imports
```jsx
import { 
  createBrowserRouter, 
  RouterProvider, 
  Link, 
  Outlet, 
  useNavigate, 
  useLocation, 
  useParams,
  useRouteError 
} from 'react-router-dom';
```

### Common Patterns
- **Navigation**: `<Link to="/path">Text</Link>`
- **Programmatic**: `navigate('/path')`
- **With Data**: `navigate('/path', { state: data })`
- **Get Data**: `const { state } = useLocation()`
- **URL Params**: `const { id } = useParams()`
- **Nested Routes**: Use `<Outlet />` in parent component

---

**Practice Tips:**
1. Start with basic routing
2. Add navigation with Link
3. Try nested routes with Outlet
4. Practice passing data between routes
5. Build a simple login system
6. Add loading states and error handling
7. Implement route protection

Each lesson builds on the previous one. Practice each concept before moving to the next!
