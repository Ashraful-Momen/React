Sure âœ… hereâ€™s your note rewritten **exactly in your style** â€” clean, short, and stepwise (with headings, explanations, and comments).

---

# -------------------------------------------

# **** React useCallback Hook ****

# -------------------------------------------

ðŸ‘‰ **When to use:**
From parent component pass a function to the `<Message>` child component.
Then call that function from the child component â€” the function actually exists in the **Parent**.

---

### ðŸ§  Problem:

When click the **Toggle** button,
the `<Message>` child component re-renders automatically â€”
even though the `count` value did **not** change.

ðŸ‘‰ This happens because the callback function passed to `<Message>`
gets **re-created** on every render.
So, React thinks props changed â†’ and re-renders the child.

---

### âš™ï¸ Solve:

Use the **useCallback()** hook.
This hook **memoizes the function** â€” keeps the same reference
until its dependency variable changes.

âœ… Syntax:

```js
useCallback(() => { ... }, [dependency_variable])
```

---

### ðŸ”¹ Example:

```jsx
const handleIncrementMessage = useCallback(() => {
    setCount((count) => count + 1);
}, [count]);
```

---

# -------------------------------------------

# **** App Component ****

# -------------------------------------------

```jsx
import React, { useState, useCallback } from "react";
import Message from "./Message";

function App() {
    const [count, setCount] = useState(0);
    const [toggle, setToggle] = useState(false);
    console.log("App rendering");

    // ---- Without useCallback ----
    // const handleIncrementMessage = () => {
    //     setCount((count) => count + 1);
    // };

    // ---- Solve using useCallback ----
    const handleIncrementMessage = useCallback(() => {
        setCount((count) => count + 1);
    }, [count]);

    return (
        <>
            {toggle ? "On" : "Off"}
            <button onClick={() => setToggle(!toggle)}>Toggle</button>

            <h2>Count: {count}</h2>

            {/* Closer function: update count directly */}
            <button
                onClick={() => {
                    setCount((count) => count + 1);
                }}
            >
                Increment
            </button>

            {/* Pass the callback function to the child */}
            <Message
                numberOfMessages={count}
                onHandleIncrement={handleIncrementMessage}
            />
        </>
    );
}

export default App;
```

---

# -------------------------------------------

# **** Message Component ****

# -------------------------------------------

```jsx
import React, { memo } from "react";

const Message = ({ numberOfMessages, onHandleIncrement }) => {
    console.log("Message rendering");

    return (
        <>
            <p>Send {numberOfMessages} message</p>

            {/* Call parent function to update count */}
            <button onClick={onHandleIncrement}>
                Increment Message Number
            </button>
        </>
    );
};

// âœ… memo() => re-render only when props change
export default memo(Message);
```

---

### ðŸ§© Summary:

* `memo()` â†’ prevents child re-render if props are same.
* `useCallback()` â†’ keeps function reference same between renders.
* If only `count` changes â†’ re-render allowed.
* If only `toggle` changes â†’ child wonâ€™t re-render.
* Use functional state update â†’ `setCount(c => c + 1)` to keep callback stable.

---

Would you like me to make a **diagram (in your note style)** showing how `memo` + `useCallback` work together in memory?
