
---

# -------------------------------------------

# **** React useReducer Hook ****

# -------------------------------------------

## 🎯 Purpose:

`useReducer` is used to manage **complex state logic** or **multiple related states**
in one place (like `Redux`, but local to the component).

---

## ⚙️ **ASCII Flow (Data Flow Diagram)**

```
User Action  --->  dispatch({ type, payload })  
                      ↓
                  Reducer Function
                      ↓
           (update state based on type/payload)
                      ↓
                 return new state
                      ↓
           Component gets updated UI
```

---

## 🧠 **Key Points:**

1. `useReducer()` takes **two things:**

   * A **reducer function**
   * An **initial state**

2. Reducer function syntax:

   ```js
   (state, action) => newState
   ```

   * `state` → current data
   * `action` → object that has `{ type, payload }`

3. You use `dispatch()` to send an **action** to reducer.

4. Reducer returns a **new state object**, not mutate old one.

5. Best for **CRUD**, **Form Handling**, or **Global State Logic**.

---

# -------------------------------------------

# **** Step-by-Step CRUD Example ****

# -------------------------------------------

## 1️⃣ Initial Data

```js
const booksData = [
  { id: 1, name: "Ashraful" },
  { id: 2, name: "Momen" },
];
```

---

## 2️⃣ Reducer Function

```js
const reducer = (state, action) => {
  if (action.type === "ADD") {
    const allBooks = [...state.books, action.payload];
    return {
      ...state,
      books: allBooks,
      isModalOpen: true,
      modalText: "Book Added Successfully!",
    };
  }

  if (action.type === "REMOVE") {
    const filtered = state.books.filter((b) => b.id !== action.payload);
    return {
      ...state,
      books: filtered,
      isModalOpen: true,
      modalText: "Book Removed!",
    };
  }

  return state;
};
```

---

## 3️⃣ Initial State

```js
const initialState = {
  books: booksData,
  isModalOpen: false,
  modalText: "",
};
```

---

## 4️⃣ Main Component

```jsx
import React, { useReducer, useState } from "react";

// Reusable Modal
const Modal = ({ modalText }) => <p>{modalText}</p>;

const UseReducer = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const [bookName, setBookName] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();

    if (bookName.trim() === "") return;

    const newBook = {
      id: new Date().getTime().toString(),
      name: bookName,
    };

    // send data to reducer
    dispatch({ type: "ADD", payload: newBook });
    setBookName("");
  };

  const removeBook = (id) => {
    dispatch({ type: "REMOVE", payload: id });
  };

  return (
    <div>
      <h3>📚 Book List</h3>

      {/* Add Book */}
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={bookName}
          onChange={(e) => setBookName(e.target.value)}
        />
        <button type="submit">Add Book</button>
      </form>

      {/* Show Modal */}
      {state.isModalOpen && <Modal modalText={state.modalText} />}

      {/* Show Books */}
      <ul>
        {state.books.map((book) => (
          <li key={book.id}>
            {book.name}{" "}
            <button onClick={() => removeBook(book.id)}>Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default UseReducer;
```

---

# -------------------------------------------

# **** Step-by-Step Flow Summary ****

# -------------------------------------------

### 🧩 When user clicks **Add Book**:

1. `dispatch({type: "ADD", payload: newBook})` fires
2. Reducer catches `type: "ADD"`
3. Updates the state → adds new book → sets `isModalOpen=true`
4. Component re-renders with new list and modal text

---

### 🧩 When user clicks **Remove Book**:

1. `dispatch({type: "REMOVE", payload: id})` fires
2. Reducer filters out the book by `id`
3. Updates state and modal message
4. UI re-renders showing updated book list

---

# -------------------------------------------

# **** Extra Tips ****

# -------------------------------------------

✅ Use `useReducer` instead of `useState` when:

* Multiple states depend on each other
* You need to handle many actions (like CRUD)
* You want cleaner, central logic for updating state

✅ `dispatch()` replaces multiple `setState()` calls.

✅ Reducer must always return **a new object**, not mutate old state.

---

Would you like me to show the **folder structure version (App + reducer.js file)** in your style next (Main part 2 in your example)?
