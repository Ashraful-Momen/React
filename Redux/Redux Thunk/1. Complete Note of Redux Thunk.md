# Complete Redux Toolkit with createAsyncThunk CRUD Guide

## Table of Contents
1. [Introduction](#introduction)
2. [Setup and Installation](#setup-and-installation)
3. [Understanding createAsyncThunk](#understanding-createasyncthunk)
4. [Understanding extraReducers](#understanding-extrareducers)
5. [Complete CRUD Implementation](#complete-crud-implementation)
6. [Using in Components](#using-in-components)
7. [Best Practices](#best-practices)

## Introduction

**Redux Toolkit** is the official, recommended way to write Redux logic. **createAsyncThunk** is a utility that simplifies the process of handling asynchronous operations in Redux.

**extraReducers** allows you to handle actions that weren't defined in the current slice, including the automatically generated action types from createAsyncThunk.

## Setup and Installation

```bash
npm install @reduxjs/toolkit react-redux axios
```

## Understanding createAsyncThunk

createAsyncThunk automatically generates action creators and action types for pending, fulfilled, and rejected states.

### Basic Syntax:
```javascript
const asyncThunk = createAsyncThunk(
  'sliceName/actionName',    // Action type prefix
  async (payload, thunkAPI) => {
    // Async logic here
    // Return the result
  }
);
```

### Parameters:
- **payload**: Data passed when dispatching the action
- **thunkAPI**: Object containing dispatch, getState, rejectWithValue, etc.

## Understanding extraReducers

extraReducers allows you to respond to action types that weren't defined in the current slice. It's perfect for handling createAsyncThunk actions.

### Two ways to define extraReducers:

1. **Builder Pattern** (Recommended):
```javascript
extraReducers: (builder) => {
  builder
    .addCase(asyncAction.pending, (state) => {})
    .addCase(asyncAction.fulfilled, (state, action) => {})
    .addCase(asyncAction.rejected, (state, action) => {});
}
```

2. **Object Syntax**:
```javascript
extraReducers: {
  [asyncAction.pending]: (state) => {},
  [asyncAction.fulfilled]: (state, action) => {},
  [asyncAction.rejected]: (state, action) => {},
}
```

## Complete CRUD Implementation

Here's a complete implementation with all CRUD operations:

### postsSlice.js

```javascript
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

const API_URL = "https://jsonplaceholder.typicode.com/posts";

// Initial State
const initialState = {
  posts: [],
  currentPost: null,
  isLoading: false,
  error: null,
  successMessage: null,
};

// CREATE - Add new post
export const createPost = createAsyncThunk(
  "posts/createPost",
  async (postData, { rejectWithValue }) => {
    try {
      const response = await axios.post(API_URL, postData);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

// READ - Fetch all posts
export const fetchPosts = createAsyncThunk(
  "posts/fetchPosts",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get(API_URL);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

// READ - Fetch single post by ID
export const fetchPostById = createAsyncThunk(
  "posts/fetchPostById",
  async (postId, { rejectWithValue }) => {
    try {
      const response = await axios.get(`${API_URL}/${postId}`);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

// UPDATE - Update existing post
export const updatePost = createAsyncThunk(
  "posts/updatePost",
  async ({ id, postData }, { rejectWithValue }) => {
    try {
      const response = await axios.put(`${API_URL}/${id}`, postData);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

// DELETE - Delete post
export const deletePost = createAsyncThunk(
  "posts/deletePost",
  async (postId, { rejectWithValue }) => {
    try {
      await axios.delete(`${API_URL}/${postId}`);
      return postId; // Return the deleted post ID
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

// Slice
export const postsSlice = createSlice({
  name: "posts",
  initialState,
  reducers: {
    // Synchronous reducers
    clearCurrentPost: (state) => {
      state.currentPost = null;
    },
    clearMessages: (state) => {
      state.error = null;
      state.successMessage = null;
    },
    setCurrentPost: (state, action) => {
      state.currentPost = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      // CREATE POST
      .addCase(createPost.pending, (state) => {
        state.isLoading = true;
        state.error = null;
        state.successMessage = null;
      })
      .addCase(createPost.fulfilled, (state, action) => {
        state.isLoading = false;
        state.posts.unshift(action.payload); // Add to beginning of array
        state.successMessage = "Post created successfully!";
        state.error = null;
      })
      .addCase(createPost.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
        state.successMessage = null;
      })

      // FETCH ALL POSTS
      .addCase(fetchPosts.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.isLoading = false;
        state.posts = action.payload;
        state.error = null;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
        state.posts = [];
      })

      // FETCH SINGLE POST
      .addCase(fetchPostById.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchPostById.fulfilled, (state, action) => {
        state.isLoading = false;
        state.currentPost = action.payload;
        state.error = null;
      })
      .addCase(fetchPostById.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
        state.currentPost = null;
      })

      // UPDATE POST
      .addCase(updatePost.pending, (state) => {
        state.isLoading = true;
        state.error = null;
        state.successMessage = null;
      })
      .addCase(updatePost.fulfilled, (state, action) => {
        state.isLoading = false;
        const index = state.posts.findIndex(post => post.id === action.payload.id);
        if (index !== -1) {
          state.posts[index] = action.payload;
        }
        state.currentPost = action.payload;
        state.successMessage = "Post updated successfully!";
        state.error = null;
      })
      .addCase(updatePost.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
        state.successMessage = null;
      })

      // DELETE POST
      .addCase(deletePost.pending, (state) => {
        state.isLoading = true;
        state.error = null;
        state.successMessage = null;
      })
      .addCase(deletePost.fulfilled, (state, action) => {
        state.isLoading = false;
        state.posts = state.posts.filter(post => post.id !== action.payload);
        state.successMessage = "Post deleted successfully!";
        state.error = null;
      })
      .addCase(deletePost.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
        state.successMessage = null;
      });
  },
});

// Export actions
export const { clearCurrentPost, clearMessages, setCurrentPost } = postsSlice.actions;

// Export reducer
export default postsSlice.reducer;
```

### store.js

```javascript
import { configureStore } from '@reduxjs/toolkit';
import postsReducer from './postsSlice';

export const store = configureStore({
  reducer: {
    posts: postsReducer,
  },
});
```

## Using in Components

### App.js - Setup Provider

```javascript
import React from 'react';
import { Provider } from 'react-redux';
import { store } from './store';
import PostsList from './PostsList';
import CreatePost from './CreatePost';

function App() {
  return (
    <Provider store={store}>
      <div className="App">
        <h1>Redux Toolkit CRUD Example</h1>
        <CreatePost />
        <PostsList />
      </div>
    </Provider>
  );
}

export default App;
```

### PostsList.js - Display and Delete Posts

```javascript
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchPosts, deletePost, clearMessages } from './postsSlice';

const PostsList = () => {
  const dispatch = useDispatch();
  const { posts, isLoading, error, successMessage } = useSelector(state => state.posts);
  const [editingPost, setEditingPost] = useState(null);

  useEffect(() => {
    dispatch(fetchPosts());
  }, [dispatch]);

  useEffect(() => {
    if (successMessage || error) {
      const timer = setTimeout(() => {
        dispatch(clearMessages());
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [successMessage, error, dispatch]);

  const handleDelete = (postId) => {
    if (window.confirm('Are you sure you want to delete this post?')) {
      dispatch(deletePost(postId));
    }
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <h2>Posts List</h2>
      
      {error && <div style={{color: 'red'}}>Error: {error}</div>}
      {successMessage && <div style={{color: 'green'}}>{successMessage}</div>}

      <div>
        {posts.map(post => (
          <div key={post.id} style={{border: '1px solid #ccc', margin: '10px', padding: '10px'}}>
            <h3>{post.title}</h3>
            <p>{post.body}</p>
            <div>
              <button onClick={() => setEditingPost(post)}>Edit</button>
              <button 
                onClick={() => handleDelete(post.id)}
                style={{marginLeft: '10px', backgroundColor: 'red', color: 'white'}}
              >
                Delete
              </button>
            </div>
          </div>
        ))}
      </div>

      {editingPost && (
        <EditPost 
          post={editingPost} 
          onClose={() => setEditingPost(null)} 
        />
      )}
    </div>
  );
};

export default PostsList;
```

### CreatePost.js - Create New Posts

```javascript
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { createPost } from './postsSlice';

const CreatePost = () => {
  const dispatch = useDispatch();
  const { isLoading } = useSelector(state => state.posts);
  const [formData, setFormData] = useState({
    title: '',
    body: '',
    userId: 1
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    if (formData.title.trim() && formData.body.trim()) {
      dispatch(createPost(formData));
      setFormData({ title: '', body: '', userId: 1 }); // Reset form
    }
  };

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  return (
    <div>
      <h2>Create New Post</h2>
      <form onSubmit={handleSubmit}>
        <div>
          <input
            type="text"
            name="title"
            placeholder="Post Title"
            value={formData.title}
            onChange={handleChange}
            style={{width: '100%', marginBottom: '10px', padding: '5px'}}
          />
        </div>
        <div>
          <textarea
            name="body"
            placeholder="Post Body"
            value={formData.body}
            onChange={handleChange}
            rows="4"
            style={{width: '100%', marginBottom: '10px', padding: '5px'}}
          />
        </div>
        <button 
          type="submit" 
          disabled={isLoading}
          style={{padding: '10px 20px'}}
        >
          {isLoading ? 'Creating...' : 'Create Post'}
        </button>
      </form>
    </div>
  );
};

export default CreatePost;
```

### EditPost.js - Update Posts

```javascript
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { updatePost } from './postsSlice';

const EditPost = ({ post, onClose }) => {
  const dispatch = useDispatch();
  const { isLoading } = useSelector(state => state.posts);
  const [formData, setFormData] = useState({
    title: post.title,
    body: post.body,
    userId: post.userId
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    if (formData.title.trim() && formData.body.trim()) {
      dispatch(updatePost({ 
        id: post.id, 
        postData: formData 
      }));
      onClose();
    }
  };

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.5)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }}>
      <div style={{
        backgroundColor: 'white',
        padding: '20px',
        borderRadius: '5px',
        width: '90%',
        maxWidth: '500px'
      }}>
        <h2>Edit Post</h2>
        <form onSubmit={handleSubmit}>
          <div>
            <input
              type="text"
              name="title"
              placeholder="Post Title"
              value={formData.title}
              onChange={handleChange}
              style={{width: '100%', marginBottom: '10px', padding: '5px'}}
            />
          </div>
          <div>
            <textarea
              name="body"
              placeholder="Post Body"
              value={formData.body}
              onChange={handleChange}
              rows="4"
              style={{width: '100%', marginBottom: '10px', padding: '5px'}}
            />
          </div>
          <div>
            <button 
              type="submit" 
              disabled={isLoading}
              style={{padding: '10px 20px', marginRight: '10px'}}
            >
              {isLoading ? 'Updating...' : 'Update Post'}
            </button>
            <button 
              type="button" 
              onClick={onClose}
              style={{padding: '10px 20px'}}
            >
              Cancel
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default EditPost;
```

## Best Practices

### 1. Error Handling
Always use `rejectWithValue` for consistent error handling:

```javascript
export const fetchData = createAsyncThunk(
  "data/fetchData",
  async (params, { rejectWithValue }) => {
    try {
      const response = await api.getData(params);
      return response.data;
    } catch (error) {
      // Return a consistent error format
      return rejectWithValue(
        error.response?.data?.message || error.message || 'Something went wrong'
      );
    }
  }
);
```

### 2. Loading States
Always handle loading states for better UX:

```javascript
// In your component
const { isLoading, error } = useSelector(state => state.posts);

if (isLoading) return <LoadingSpinner />;
if (error) return <ErrorMessage error={error} />;
```

### 3. Conditional Dispatching
Prevent unnecessary API calls:

```javascript
const handleFetchPosts = () => {
  if (posts.length === 0 && !isLoading) {
    dispatch(fetchPosts());
  }
};
```

### 4. Optimistic Updates
For better UX, especially on delete operations:

```javascript
.addCase(deletePost.pending, (state, action) => {
  state.isLoading = true;
  // Optimistically remove the post
  state.posts = state.posts.filter(post => post.id !== action.meta.arg);
})
.addCase(deletePost.rejected, (state, action) => {
  state.isLoading = false;
  state.error = action.payload;
  // Refetch posts to restore the state
  // Or keep a backup and restore it
});
```

### 5. Typed Parameters
For complex parameters, consider using TypeScript:

```typescript
interface UpdatePostParams {
  id: number;
  postData: {
    title: string;
    body: string;
    userId: number;
  };
}

export const updatePost = createAsyncThunk<Post, UpdatePostParams>(
  "posts/updatePost",
  async ({ id, postData }, { rejectWithValue }) => {
    // Implementation
  }
);
```

This complete guide covers everything you need to implement CRUD operations with Redux Toolkit and createAsyncThunk. The pattern is consistent across all operations, making it easy to maintain and scale your application.
