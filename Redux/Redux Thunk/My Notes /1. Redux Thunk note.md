# Complete Redux Toolkit CRUD with Async Thunks Guide

## Overview
This guide demonstrates a complete CRUD (Create, Read, Update, Delete) application using Redux Toolkit with `createAsyncThunk` for handling asynchronous operations. The application manages posts with full CRUD functionality including optimistic UI updates and error handling.

## Project Structure
```
src/
├── app/
│   └── store.js          # Redux store configuration
├── feature/
│   ├── postSlice.js      # Redux slice with async thunks
│   └── PostView.jsx      # React component
├── App.jsx               # Main app component
└── index.js              # App entry point with Provider
```

## 1. Redux Store Configuration (`store.js`)

```javascript
import { configureStore } from '@reduxjs/toolkit';
import postSlice from '../feature/postSlice'

export const store = configureStore({
  reducer: {
    postR: postSlice,  // 'postR' is the state key
  }
});
```

**Key Points:**
- Uses `configureStore` from Redux Toolkit
- Registers the post slice reducer under the key `postR`
- Automatically includes Redux DevTools and middleware

## 2. Redux Slice with Async Thunks (`postSlice.js`)

### Initial State
```javascript
const initialState = {
  posts: [],
  isLoading: false,
  error: null,
};
```

### Async Thunk Actions

#### Fetch Posts
```javascript
export const fetchPosts = createAsyncThunk("posts/fetchPosts", async () => {
  const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
  return response.data;
});
```

#### Delete Post
```javascript
export const deletePost = createAsyncThunk("post/deletePost", async (id) => {
  const response = await axios.delete(`https://jsonplaceholder.typicode.com/posts/${id}`);
  return id; // Return the ID for state update
});
```

#### Create Post
```javascript
export const createPost = createAsyncThunk("post/createPost", async (postData) => {
  const response = await axios.post(`https://jsonplaceholder.typicode.com/posts`, postData);
  return response.data; // Return the new post
});
```

#### Update Post
```javascript
export const updatePost = createAsyncThunk("post/updatePost", async ({ id, postData }) => {
  const response = await axios.put(`https://jsonplaceholder.typicode.com/posts/${id}`, postData);
  return { id, ...response.data }; // Return ID + updated data
});
```

### Extra Reducers (State Management)

The slice uses `extraReducers` with the builder pattern to handle async thunk lifecycle:

#### Fetch Posts Handlers
```javascript
builder
  .addCase(fetchPosts.pending, (state) => {
    state.isLoading = true;
    state.posts = [];
    state.error = null;
  })
  .addCase(fetchPosts.fulfilled, (state, action) => {
    state.isLoading = false;
    state.posts = action.payload;
    state.error = null;
  })
  .addCase(fetchPosts.rejected, (state, action) => {
    state.isLoading = false;
    state.error = action.error.message;
    state.posts = [];
  });
```

#### Delete Post Handlers
```javascript
builder
  .addCase(deletePost.fulfilled, (state, action) => {
    state.isLoading = false;
    state.posts = state.posts.filter((post) => post.id != action.payload);
    state.error = null;
  })
```

#### Create Post Handlers
```javascript
builder
  .addCase(createPost.fulfilled, (state, action) => {
    state.isLoading = false;
    // Add new post to beginning of array
    state.posts = [action.payload, ...state.posts];
    state.error = null;
  })
```

#### Update Post Handlers
```javascript
builder
  .addCase(updatePost.fulfilled, (state, action) => {
    state.isLoading = false;
    // Find and replace the updated post
    const index = state.posts.findIndex((post) => post.id === action.payload.id);
    if (index !== -1) {
      state.posts[index] = action.payload;
    }
    state.error = null;
  })
```

## 3. React Component (`PostView.jsx`)

### Component Setup
```javascript
import React, { useState, useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { fetchPosts, deletePost, createPost, updatePost } from "./postSlice";

const PostView = () => {
  // Get state from Redux store
  const { posts, isLoading, error } = useSelector((state) => state.postR);
  const dispatch = useDispatch();
  
  // Local state for edit mode
  const [editingPost, setEditingPost] = useState(null);
```

### useEffect for Initial Data Loading
```javascript
useEffect(() => {
  dispatch(fetchPosts());
}, [dispatch]);
```

### Event Handlers

#### Delete Handler
```javascript
const handleDeletePost = (id) => {
  dispatch(deletePost(id));
};
```

#### Create Handler
```javascript
const handleCreatePost = (postData) => {
  dispatch(createPost(postData));
};
```

#### Update Handler
```javascript
const handleUpdatePost = (id, postData) => {
  dispatch(updatePost({ id, postData }));
  setEditingPost(null); // Exit edit mode
};
```

#### Edit Toggle Handler
```javascript
const handleEditToggle = (post) => {
  setEditingPost(editingPost?.id === post.id ? null : post);
};
```

### Form Handling Pattern
```javascript
<form onSubmit={(e) => {
  e.preventDefault();
  const formData = new FormData(e.target);
  const postData = {
    title: formData.get("title"),
    body: formData.get("body"),
    userId: 1,
  };
  handleCreatePost(postData);
  e.target.reset(); // Clear form
}}>
```

### Conditional Rendering for Edit Mode
```javascript
{editingPost?.id === post.id ? (
  // Edit Form JSX
) : (
  // Display Mode JSX
)}
```

## 4. App Setup

### Main App Component (`App.jsx`)
```javascript
import PostView from "./feature/PostView";

function App() {
  return (
    <div>
      <PostView />
    </div>
  );
}
```

### Entry Point with Provider (`index.js`)
```javascript
import { createRoot } from 'react-dom/client'
import { Provider } from 'react-redux'
import 'bootstrap/dist/css/bootstrap.min.css'
import { store } from './app/store'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

## Key Patterns and Best Practices

### 1. Async Thunk Lifecycle Management
- **Pending**: Set loading state, clear errors
- **Fulfilled**: Update data, clear loading/errors
- **Rejected**: Handle errors, clear loading

### 2. State Updates
- **Immutable Updates**: Redux Toolkit uses Immer internally
- **Optimistic Updates**: Update UI immediately, handle errors separately
- **Array Operations**: Filter for delete, prepend for create, find/replace for update

### 3. Form Handling
- Use `FormData` API for form processing
- Reset forms after successful submission
- Use `defaultValue` for edit forms

### 4. Component Patterns
- Separate concerns: Redux logic in slice, UI logic in component
- Use local state for UI-only state (edit mode)
- Conditional rendering for different modes

### 5. Error Handling
- Global error state in Redux
- Display errors in UI
- Reset errors on new operations

### 6. Loading States
- Global loading state for better UX
- Disable forms/buttons during loading
- Show loading indicators

## API Integration Notes

### JSONPlaceholder API Endpoints
- **GET** `/posts` - Fetch all posts
- **POST** `/posts` - Create new post
- **PUT** `/posts/:id` - Update existing post
- **DELETE** `/posts/:id` - Delete post

### Response Handling
- Always return relevant data from async thunks
- For delete operations, return the ID
- For create/update, return the full object
- Handle both success and error responses

## Common Issues and Solutions

### 1. State Key Mismatch
Ensure the selector matches the store configuration:
```javascript
// Store
postR: postSlice

// Selector
const { posts } = useSelector((state) => state.postR);
```

### 2. Form Reset
Always reset forms after successful operations:
```javascript
e.target.reset(); // Clear form after submission
```

### 3. Edit Mode Management
Use local state to track which post is being edited:
```javascript
const [editingPost, setEditingPost] = useState(null);
```

### 4. Async Thunk Parameters
For operations requiring multiple parameters, use object destructuring:
```javascript
// Thunk
async ({ id, postData }) => { ... }

// Dispatch
dispatch(updatePost({ id, postData }));
```

This implementation provides a solid foundation for any CRUD application using Redux Toolkit with proper state management, error handling, and user experience patterns.
